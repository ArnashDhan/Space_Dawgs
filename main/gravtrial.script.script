local SCREEN_WIDTH = 1920
local SCREEN_HEIGHT = 1080
local ACCELERATION = 200
local BULLET_SPEED = 200

function init(self)
	msg.post(".", "acquire_input_focus")
	self.velocity = vmath.vector3()
	self.input = vmath.vector3()
	self.firing = false
	self.mass = 100 -- Set an appropriate mass value for the mainship
end

local function calculate_gravitational_force(self, hole)
	local G = 6.674 * math.pow(10, -11)  -- Gravitational constant
	local distance = vmath.length(go.get_position() - hole)
	local forceMagnitude = (G * self.mass * hole.mass) / math.pow(distance, 2)
	local forceDirection = vmath.normalize(hole - go.get_position())
	print(string.format("Gravitational Force: Magnitude - %.2f, Direction - (%.2f, %.2f)", forceMagnitude, forceDirection.x, forceDirection.y))
	return forceMagnitude, forceDirection
end

local function apply_gravitational_force(self, dt, hole)
	local forceMagnitude, forceDirection = calculate_gravitational_force(self, hole)
	local gravitationalForce = forceDirection * forceMagnitude
	self.velocity = self.velocity + gravitationalForce * dt

	print(string.format("Gravitational Force: Magnitude - %.2f, Direction - (%.2f, %.2f)", forceMagnitude, forceDirection.x, forceDirection.y))
end

local function move_spaceship(self, dt)
	local steerspeed = 2.5
	local movespeed = 250
	local acceleration = 1000 
	local maxSpeed = 500
	local angularDamping = 0.9  
	self.acceleration = self.acceleration or vmath.vector3(0, 0, 0)
	self.angularVelocity = self.angularVelocity or 0

	if vmath.length_sqr(self.input) > 0 then
		self.input = vmath.normalize(self.input)
	end

	local steeramount = -self.input.x * steerspeed
	local speed = self.input.y * movespeed
	local rotatedAcceleration = vmath.rotate(go.get_rotation(), self.input * acceleration)

	self.velocity = self.velocity + rotatedAcceleration * dt

	if vmath.length_sqr(self.velocity) > maxSpeed * maxSpeed then
		self.velocity = vmath.normalize(self.velocity) * maxSpeed
	end

	self.angularVelocity = self.angularVelocity * angularDamping + steeramount * (1 - angularDamping)
	go.set_rotation(go.get_rotation() * vmath.quat_rotation_z(self.angularVelocity * dt))

	local pos = go.get_position()
	pos = pos + self.velocity * dt
	go.set_position(pos)

	self.input.x = 0
	self.input.y = 0
	self.firing = false
	self.moving = false
end

local function enforce_boundary_constraints(self)
	local p = go.get_position()

	-- Clamp X-coordinate to keep the spaceship within the horizontal bounds
	p.x = math.max(0, math.min(SCREEN_WIDTH, p.x))

	-- Clamp Y-coordinate to keep the spaceship within the vertical bounds
	p.y = math.max(0, math.min(SCREEN_HEIGHT, p.y))

	go.set_position(p)
end

local function firebullet(self)
	-- Create a direction vector pointing upwards
	local dir = vmath.vector3(0, 1, 0)
	-- Create a bullet using the factory
	local bullet = factory.create("#factory", go.get_position(), nil, {}, 1)
end

function update(self, dt)
	move_spaceship(self, dt)
	enforce_boundary_constraints(self)
end

function on_input(self, action_id, action)
	if action_id == hash("up") then
		self.input.y = 1
	elseif action_id == hash("left") then
		self.input.x = -1
	elseif action_id == hash("right") then
		self.input.x = 1
	elseif action_id == hash("fire") and action.pressed then
		self.firing = true
		firebullet(self)
	end

	if vmath.length(self.input) > 0 then
		self.moving = true
		self.dir = vmath.normalize(self.input)
	end
end

function on_message(self, message_id, message, sender)
	if message_id == hash("trigger_response") then
		local other_id = message.other_id
		print("Entered black hole region")
		if other_id == hash("/hole") then
			local hole = go.get_position(other_id)
			apply_gravitational_force(self, dt, hole)
		end
	end
end
