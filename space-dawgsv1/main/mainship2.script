local SCREEN_WIDTH = 1910
local SCREEN_HEIGHT = 1070
local ACCELERATION = 200
local BULLET_SPEED = 200

function init(self)
	msg.post(".", "acquire_input_focus")
	self.velocity = vmath.vector3()
	self.input = vmath.vector3()
	self.firing = false
	self.in_gravitational_pull = true
	self.mass = 100
	self.initial_position = vmath.vector3(1800, 100, 0)
	self.health = 100 -- Initialize health with 100
	print("Mainship2 Initial Health: ", self.health) -- Debugging: Print initial health
end

-- Calculate gravitational force exerted by the hole on the spaceship
local function calculate_gravitational_force(self, hole)
	local G = 50 -- Gravitational constant
	local distance = vmath.length(go.get_position() - hole) 
	if distance < 5 then
		go.set_position(self.initial_position)
		self.velocity = vmath.vector3() -- Reset velocity
		self.health=self.health-10
		print("Mainship2 crashed into the black hole! Health now: ", self.health)
		if self.health <= 0 then
			print("Mainship2 destroyed! PLAYER 1 WINS")
			go.delete()
		end
	end   
	local holeMass = 10000 -- Mass of the hole
	local forceMagnitude = (G * self.mass * holeMass) / math.pow(distance, 2)
	forceMagnitude = math.min(forceMagnitude, 27500) 
	local forceDirection = vmath.normalize(hole - go.get_position()) 
	return forceMagnitude, forceDirection
end

-- Apply gravitational force to the spaceship
local function apply_gravitational_force(self, dt, hole_position)
	local forceMagnitude, forceDirection = calculate_gravitational_force(self, hole_position)
	local gravitationalForce = forceDirection * forceMagnitude
	self.velocity = self.velocity + gravitationalForce * dt 
end

-- Move the spaceship based on input and physics
local function move_spaceship(self, dt)
	local steerspeed = 2
	local movespeed = 250
	local acceleration = 1000
	local maxSpeed = 500
	local angularDamping = 0.9
	self.angularVelocity = self.angularVelocity or 0
	if vmath.length_sqr(self.input) > 0 then
		self.input = vmath.normalize(self.input)
	end
	local steeramount = -self.input.x * steerspeed
	local rotatedInput = vmath.rotate(go.get_rotation(), self.input) -- 
	local rotatedAcceleration = rotatedInput * acceleration -- Apply acceleration
	self.velocity = self.velocity + rotatedAcceleration * dt -- Update velocity
	if vmath.length_sqr(self.velocity) > maxSpeed * maxSpeed then
		self.velocity = vmath.normalize(self.velocity) * maxSpeed -- Cap velocity at max speed
	end
	self.angularVelocity = self.angularVelocity * angularDamping + steeramount * (1 - angularDamping) -- Update angular velocity
	go.set_rotation(go.get_rotation() * vmath.quat_rotation_z(self.angularVelocity * dt)) -- Apply rotation
	local pos = go.get_position() + self.velocity * dt -- Update position
	go.set_position(pos) -- Set new position
	-- Reset input after movement
	self.input.x = 0
	self.input.y = 0
	self.firing = false
end

-- Ensure the spaceship stays within the screen boundaries
local function enforce_boundary_constraints(self)
	local p = go.get_position()
	p.x = math.max(0, math.min(SCREEN_WIDTH, p.x))
	p.y = math.max(0, math.min(SCREEN_HEIGHT, p.y))
	go.set_position(p)
end

-- Fire a bullet
local function firebullet(self)
	local dir = vmath.vector3(0, 1, 0) -- Direction of the bullet
	factory.create("#factory2", go.get_position(), nil, {}, 1) -- Create bullet
end

-- Main update loop
function update(self, dt)
	move_spaceship(self, dt) -- Move the spaceship
	enforce_boundary_constraints(self) -- Apply screen boundary constraints
	if self.in_gravitational_pull then
		local hole_position = vmath.vector3(960, 540, 0.1) -- Position of the hole
		apply_gravitational_force(self, dt, hole_position) -- Apply gravitational force
	end
end

-- Handle input from the player
function on_input(self, action_id, action)
	-- Define distinct input actions for mainship2
	if action_id == hash("up2") then
		self.input.y = 1
	elseif action_id == hash("left2") then
		self.input.x = -1
	elseif action_id == hash("right2") then
		self.input.x = 1
	elseif action_id == hash("fire2") and action.pressed then
		self.firing = true
		firebullet(self)
	end
end

-- Handle messages (e.g., collisions or triggers)
function on_message(self, message_id, message, sender)
	if message_id == hash("apply_damage") then
		-- This message is expected to carry the damage amount
		self.health = self.health - message.amount
		print("Mainship2 hit! Health now: ", self.health) -- Debugging: Print current health
		if self.health <= 0 then
			print("Mainship2 destroyed!") -- Debugging: Print destruction message
			go.delete() -- Example action, adjust based on your game's needs
		end
	end	
end
